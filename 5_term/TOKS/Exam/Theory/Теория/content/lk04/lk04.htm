<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">

<title>Лекция</title>
<style type="text/css">
 body {font-family: Arial, sans-serif;}
 .c {font-family: "Courier New", Courier, monospace}
</style>

</HEAD><BODY>

<div align="justify">

<p>&nbsp;</p>
<div align="center">
<p><strong>КАНАЛЬНОЕ КОДИРОВАНИЕ</strong></p>
</div>
<p>&nbsp;</p>

<p>Кодирование на канальном уровне (канальное кодирование) призвано решать две фундаментальные задачи:<br>
1.&nbsp;Адаптировать битовые последовательности к возможностям физического уровня с целью обеспечения или улучшения требующихся технических характеристик. Лучше всего это назвать <em>линейным кодированием</em> (line encoding), где слово «линейное» происходит от понятия физической линии.<br>
2.&nbsp;Обеспечить проверку целостности данных и, по возможности, восстановление ошибочных битов. Лучше всего это назвать <em>помехоустойчивым кодированием</em> (antinoise encoding).</p>

<p>Следует отметить, что терминологически линейное кодирование имеет и альтернативный смысл, происходящий от математического понятия линейных функций. В первом подразделе в этот термин будет вкладываться физический смысл, во втором -- математический.</p>

<p>Не следует путать линейное кодирование с модуляцией, выполняемой на физическом уровне. Несмотря на то, что часто эти процессы связаны неразрывно, линейное кодирование все-таки следует рассматривать как надстройку над модуляцией.</p>

<p>Фактор помех, если под помехами понимать различные электро-магнитные наводки, в КС безусловно учитывают. Но борьба с помехами -- это лишь частные случаи обеих задач (даже вторая задача порождена не только воздействием на канал наводок).</p>

<p>&nbsp;</p>
<div align="center">
<p><strong>Линейное кодирование</strong></p>
</div>
<p>&nbsp;</p>

<p>Одной из основных предпосылок для разработки линейных кодов, является проблема, проявляющаяся во многих системах передачи цифровой (и аналоговой) информации, известная как <em>девиацией несущей</em> (carrier deviation).</p>

<p>Очевидно, передатчик и приемник должны работать на одной частоте. В большинстве случаев, передатчик и приемник имеют разные источники синхронизации. При этом тактовые генераторы далеко не идентичны. Если состояние линии очень долго не изменяется, что происходит при передаче очень длинных нулевых либо единичных последовательностей с использованием классической амплитудной модуляции цифровых цепей (логический ноль соответствует земле, а логическая единица некоторому положительному потенциалу относительно земли), то приемнику «цепляться не за что». В результате накапливаются фазовые сдвиги, что в конце концов приводит к возникновению ошибок.</p>

<p>Современная схемотехническая база для борьбы с девиацией несущей имеет в распоряжении блок ФАПЧ (фазовой автоподстройки частоты), позволяющий автоматически подстраивать тактовый генератор приемника к тактовому генератору передатчика. Наиболее близкий англоязычный термин -- PLL (Phased-Locked Loop).</p>

<p>Все линейные коды, в той или иной степени, направлены на преобразование битовых последовательностей, чтобы в линии постоянно происходили изменения. В том числе, за счет равномерного распределения нулей и единиц.</p>

<p>Шесть факторов, влияющих на классификацию линейных кодов:<br>
1.&nbsp;Кодирование уровнями либо переходами.<br>
2.&nbsp;Наличие инвертирования.<br>
3.&nbsp;Однополярность либо многополярность.<br>
4.&nbsp;Наличие так называемого «возврата к нулю».<br>
5.&nbsp;Наличие самосинхронизации.<br>
6.&nbsp;Наличие перестановки или подмены битов.</p>

<p>Для изучения в рамках данной дисциплины выбраны следующие основные группы кодов:<br>
1.&nbsp;NRZ (Non-Return-to-Zero) codes -- коды без возврата к нулю.<br>
2.&nbsp;RZ (Return-to-Zero) codes -- коды с возвратом к нулю.<br>
3.&nbsp;Manchester codes -- манчестерские коды.<br>
4.&nbsp;MLT (Multi-Level Transmit) codes -- многоуровневые коды.<br>
5.&nbsp;Block codes -- блочные коды.</p>

<p>NRZ-коды выражаются в изменении уровней между тактами. В простейших случаях, логические уровни в исходной последовательности не преобразуются совсем либо инвертируются. Более сложными случаями являются space и mark. При space-варианте ноль во входной последовательности кодируется сменой текущего уровня в выходной, а единица -- сохранением текущего уровня. При mark-варианте, наоборот, единицы в исходной последовательности приводят к переключению уровней. Начальное состояние значения не имеет. Space и mark инверсны друг относительно друга. NRZ-коды могут быть однополярными и двухполярными. Требуется наличие дополнительной цепи для тактирования.</p>

<p>Примеры технологий с применением NRZ-кодов: RS-232, USB, HDLC.</p>

<div align="center">
<img src="lk04.01.01.bmp">
<br>
Рисунок -- NRZ-коды
</div>

<p>RZ-коды так же выражаются в изменении уровней между тактами, но на половине каждого такта всегда происходит возврат к нулю (земле). Двухполярные RZ-коды обладают свойством самосинхронизации.</p>

<p>Пример технологии с применением RZ-кода: IrDA.</p>

<div align="center">
<img src="lk04.01.02.bmp">
<br>
Рисунок -- RZ-коды
</div>

<p>Манчестерские коды выражаются в переходах между уровнями во время тактов, поэтому их иногда называют фазовыми кодами.
Есть два «равноправных» варианта собственно манчестерского кода. Ноль во входной последовательности заменяется на переход от единицы к нулю, а единица заменяется на переход от нуля к единице. Либо наоборот. Манчестерские коды обладают свойством самосинхронизации.</p>

<p>Еще несколько кодов близки к манчестерскому.</p>

<p>Согласно коду Миллера (Miller), ноль соответствует отсутствию перехода во время такта, единица соответствует переходу во время такта, плюс между двумя нулями всегда выполняется смена уровня.</p>

<p>Согласно коду Split Phase учитывается направление предыдущего перехода. При space-варианте ноль соответствует переходу во время такта в направлении, противоположном направлению предыдущего перехода, единица соответствуют переходу во время такта в направлении, совпадающем с направлением предыдущего перехода. При mark-варианте «роли» нулей и единиц из входной последовательности инвертируются.</p>

<p>Согласно коду Biphase, кроме возможных переходов во время тактов, всегда выполняется смена уровня между тактами. При space-варианте ноль соответствуют переходу во время такта, единица соответствуют отсутствию перехода во время такта. При mark-варианте «роли» нулей и единиц из входной последовательности инвертируются.</p>

<p>Примеры технологий с применением манчестерских кодов: Ethernet, Token Ring, некоторые IR-технологии.</p>

<div align="center">
<img src="lk04.01.03.bmp">
<br>
Рисунок -- Манчестерские коды
</div>

<p>MLT-коды выражаются в переключении между несколькими уровнями между тактами. Например, код MLT-3 имеет три уровня: -1, 0, +1. Кодирование может начинаться с нуля, ноль в исходной последовательности кодируется сохранением текущего уровня, а единица -- переходом к соседнему уровню (с сохранением направления, если это возможно).</p>

<p>Примеры технологий с применением MLT-кодов: Fast Ethernet, FDDI.</p>

<div align="center">
<img src="lk04.01.04.bmp">
<br>
Рисунок -- MLT-коды
</div>

<p>Блочные коды выражаются в замене блоков битов из входной последовательности на бо'льшие (как правило) по размеру блоки битов в выходной последовательности. Блочные коды могут комбинироваться с вышеперечисленными кодами. В связи с избыточностью блочных кодов, во многих из них предусмотрены контрольные последовательности, которые, по сути, являются управляющими символами.</p>

<p>Первым примером может служить код 4b/5b, применяемый в Fast Ethernet и CDDI.</p>

<p>Таблица -- Основная таблица кода 4b/5b
<table border="1" cellspacing="1" cellpadding="1">
<tr><td align="center">4b</td><td align="center">5b</td></tr>
<tr><td align="center">0000</td><td align="center">11110</td></tr>
<tr><td align="center">0001</td><td align="center">01001</td></tr>
<tr><td align="center">0010</td><td align="center">10100</td></tr>
<tr><td align="center">0011</td><td align="center">10101</td></tr>
<tr><td align="center">0100</td><td align="center">01010</td></tr>
<tr><td align="center">0101</td><td align="center">01011</td></tr>
<tr><td align="center">0110</td><td align="center">01110</td></tr>
<tr><td align="center">0111</td><td align="center">01111</td></tr>
<tr><td align="center">1000</td><td align="center">10010</td></tr>
<tr><td align="center">1001</td><td align="center">10011</td></tr>
<tr><td align="center">1010</td><td align="center">10110</td></tr>
<tr><td align="center">1011</td><td align="center">10111</td></tr>
<tr><td align="center">1100</td><td align="center">11010</td></tr>
<tr><td align="center">1101</td><td align="center">11011</td></tr>
<tr><td align="center">1110</td><td align="center">11100</td></tr>
<tr><td align="center">1111</td><td align="center">11101</td></tr>
</table>
</p>

<p>Более сложным примером может служить код 8b/10b, применяемый в оптических вариантах Gigabit Ethernet.
Биты входного блока обозначают как <em>ABCDEFGH</em> -- от младшего к старшему, выходного <em>abcdefghij</em> -- так же от младшего к старшему. Входной блок разбивается на два подблока: <em>x</em> из пяти битов и <em>y</em> из трех битов. Поэтому выходной код представляет собой конкатенацию двух кодов: 5b/6b и 3b/4b. Кроме собственно блоков данных <em>D</em>, имеются контрольные блоки <em>K</em>, которые кодируют альтернативно. Таким образом, входной блок обозначают как <em>D</em><sub><em>x</em>.<em>y</em></sub> либо <em>K</em><sub><em>x</em>.<em>y</em></sub>. Наконец, в код 8b/10b заложена гибкая система уравнивания количества нулей и количества единиц, заключающаяся в динамическом выборе блока для замены (одного из двух) исходя из текущего значения так называемого RD (Running Disparity). Предусмотрено два значения RD: -1 и +1. При выборе текущего значения RD учитывается предыдущее значение RD и соотношение нулей и единиц во входном блоке (плюс есть исключения).</p>

<p>Таблица -- Одна из таблиц кода 8b/10b
<table border="1" cellspacing="1" cellpadding="1">
<tr><td align="center">5b</td><td colspan="2" align="center">6b</td><td align="center">5b</td><td colspan="2" align="center">6b</td></tr>
<tr><td align="center"><em>EDCBA</em></td><td colspan="2" align="center"><em>abcdei</em></td><td align="center"><em>EDCBA</em></td><td colspan="2" align="center"><em>abcdei</em></td></tr>
<tr><td align="center"><em>D</em></td><td align="center">RD = -1</td><td align="center">RD = +1</td><td align="center"><em>D</em></td><td align="center">RD = -1</td><td align="center">RD = +1</td></tr>
<tr><td align="center">00000</td><td align="center">100111</td><td align="center">011000</td><td align="center">10000</td><td align="center">011011</td><td align="center">100100</td></tr>
<tr><td align="center">00001</td><td align="center">011101</td><td align="center">100010</td><td align="center">10001</td><td colspan="2" align="center">100011</td></tr>
<tr><td align="center">00010</td><td align="center">101101</td><td align="center">010010</td><td align="center">10010</td><td colspan="2" align="center">010011</td></tr>
<tr><td align="center">00011</td><td colspan="2" align="center">110001</td><td align="center">10011</td><td colspan="2" align="center">110010</td></tr>
<tr><td align="center">00100</td><td align="center">110101</td><td align="center">001010</td><td align="center">10100</td><td colspan="2" align="center">001011</td></tr>
<tr><td align="center">00101</td><td colspan="2" align="center">101001</td><td align="center">10101</td><td colspan="2" align="center">101010</td></tr>
<tr><td align="center">00110</td><td colspan="2" align="center">011001</td><td align="center">10110</td><td colspan="2" align="center">011010</td></tr>
<tr><td align="center">00111</td><td align="center">111000</td><td align="center">000111</td><td align="center">10111</td><td align="center">111010</td><td align="center">000101</td></tr>
<tr><td align="center">01000</td><td align="center">111001</td><td align="center">000110</td><td align="center">11000</td><td align="center">110011</td><td align="center">001100</td></tr>
<tr><td align="center">01001</td><td colspan="2" align="center">100101</td><td align="center">11001</td><td colspan="2" align="center">100110</td></tr>
<tr><td align="center">01010</td><td colspan="2" align="center">010101</td><td align="center">11010</td><td colspan="2" align="center">010110</td></tr>
<tr><td align="center">01011</td><td colspan="2" align="center">110100</td><td align="center">11011</td><td align="center">110110</td><td align="center">001001</td></tr>
<tr><td align="center">01100</td><td colspan="2" align="center">001101</td><td align="center">11100</td><td colspan="2" align="center">001110</td></tr>
<tr><td align="center">01101</td><td colspan="2" align="center">101100</td><td align="center">11101</td><td align="center">101110</td><td align="center">010001</td></tr>
<tr><td align="center">01110</td><td colspan="2" align="center">011100</td><td align="center">11110</td><td align="center">011110</td><td align="center">100001</td></tr>
<tr><td align="center">01111</td><td align="center">010111</td><td align="center">101000</td><td align="center">11111</td><td align="center">101011</td><td align="center">010100</td></tr>
</table>
</p>

<p>Таблица -- Одна из таблиц кода 8b/10b
<table border="1" cellspacing="1" cellpadding="1">
<tr><td align="center">3b</td><td colspan="2" align="center">4b</td></tr>
<tr><td align="center"><em>HGF</em></td><td colspan="2" align="center"><em>fghj</em></td></tr>
<tr><td align="center"><em>D</em></td><td align="center">RD = -1</td><td align="center">RD = +1</td></tr>
<tr><td align="center">000</td><td align="center">1011</td><td align="center">0100</td></tr>
<tr><td align="center">001</td><td colspan="2" align="center">1001</td></tr>
<tr><td align="center">010</td><td colspan="2" align="center">0101</td></tr>
<tr><td align="center">011</td><td align="center">1100</td><td align="center">0011</td></tr>
<tr><td align="center">100</td><td align="center">1101</td><td align="center">0010</td></tr>
<tr><td align="center">101</td><td colspan="2" align="center">1010</td></tr>
<tr><td align="center">110</td><td colspan="2" align="center">0110</td></tr>
<tr><td align="center">111</td><td align="center">1110</td><td align="center">0001</td></tr>
<tr><td align="center">111</td><td align="center">0111</td><td align="center">1000</td></tr>
</table>
</p>

<p>Линейные коды, применяемые в оптических каналах имеют особенности в сравнении с кодами для проводниковых каналов.</p>

<p>Примеры: TS-FO (Three of Six -- Fiber Optical), RZ carrier-suppressed, RZ alternate-phase.</p>

<p>&nbsp;</p>
<div align="center">
<p><strong>Помехоустойчивое кодирование</strong></p>
</div>
<p>&nbsp;</p>

<p>Очевидно, что неправильная интерпретация принятых данных чревата непредсказуемыми последствиями.</p>

<p>Серьезное изучение помехоустойчивого кодирования предполагает «погружение» в математику. При изучении же данной дисциплины больше важны прикладные аспекты, но без некоторых алгебраических основ не обойтись.</p>

<p>В теории помехоустойчивого кодирования очень важное место занимают поля Галуа, но чтобы к ним «подойти» нужно сделать ряд шагов.</p>

<p>Некоторую операцию * называют <em>бинарной</em> если после ее применения к двум любым элементам <em>a</em> и <em>b</em> некоторого множества получают элемент <em>c</em>, принадлежащий тому же множеству: <em>a</em>&nbsp;*&nbsp;<em>b</em>&nbsp;=&nbsp;<em>c</em>. А соответствующее непустое множество <em>S</em> называют замкнутым относительно бинарной операции *.</p>

<p>Элемент <em>e</em> множества называют <em>нейтральным</em> если, после бинарной операции над этим элементом и некоторым другим, другой участвовавший в операции элемент не изменяется: <em>a</em>&nbsp;*&nbsp;<em>e</em>&nbsp;=&nbsp;<em>a</em>.</p>

<p>Два элемента множества называют <em>обратными</em> (относительно друг друга) если в результате бинарной операции над ними получают нейтральный элемент: <em>a</em>&nbsp;*&nbsp;<em>b</em>&nbsp;=&nbsp;<em>e</em>.</p>

<p>Множество <em>G</em> называют <em>группой</em> если для него определена бинарная операция * и:<br>
1.&nbsp;Операция * является ассоциативной: (<em>a</em>&nbsp;*&nbsp;<em>b</em>)&nbsp;*<em>c</em>&nbsp;=&nbsp;<em>a</em>&nbsp;*&nbsp;(<em>b</em>&nbsp;*&nbsp;<em>c</em>) -- соответствует умножению.<br>
2.&nbsp;Существует нейтральный элемент -- соответствует единице.<br>
3.&nbsp;Имеется унарная операция, позволяющая получить обратный элементу <em>a</em> элемент -- соответствует <em>a</em><sup>-1</sup>.</p>

<p>Группу называют <em>абелевой</em> если операция * коммутативна: <em>a</em>&nbsp;*&nbsp;<em>b</em> = <em>b</em>&nbsp;*&nbsp;<em>a</em>.</p>

<p>Если для группы определена операция умножения (<em>a</em>&nbsp;*&nbsp;<em>b</em>&nbsp;=&nbsp;<em>ab</em>), то группу называют <em>мультипликативной</em>.</p>

<p>Мультипликативную группу называют <em>циклической</em> если в ней существует такой элемент, что все остальные элементы являются степенями этого элемента: <em>b</em>&nbsp;=&nbsp;<em>a</em><sup><em>k</em></sup>. А сам элемент <em>a</em> называют <em>образующим</em> группу.</p>

<p><em>Классом вычетов</em> по модулю <em>n</em>, принадлежащему множеству натуральных чисел &naturals;, называют подмножество элементов из множества целых чисел &integers;, имеющих одинаковый остаток от деления на <em>n</em>. [<em>a</em>] -- класс вычетов, одним из элементов которого является <em>a</em>.</p>

<p>Группу, образованную множеством классов вычетов по модулю <em>n</em>, называют <em>группой классов вычетов</em> по модулю <em>n</em>.</p>

<p>Группу называют <em>конечной</em> если группа состоит из конечного числа элементов. Число элементов |<em>G</em>| конечной группы называют ее <em>порядком</em>.</p>

<p>Два целых числа <em>сравнимы</em> (<em>эквивалентно равны</em>) по модулю натурального числа <em>n</em> если при делении на <em>n</em> они дают одинаковые остатки: <em>a</em> &equiv; <em>b</em> (mod <em>n</em>).</p>

<p>Отображение <em>f</em>:&nbsp;<em>G</em>&nbsp;&rarr;&nbsp;<em>H</em> группы <em>G</em> в группу <em>H</em> называют <em>гомоморфным</em> если оно сохраняет операцию группы <em>G</em>. Отображение <em>изоморфно</em> если оно взаимно однозначно. Отображение <em>f</em>:&nbsp;<em>G</em>&nbsp;&rarr;&nbsp;<em>G</em> называют <em>эпиморфным</em>, изоморфное отображение <em>f</em>:&nbsp;<em>G</em>&nbsp;&rarr;&nbsp;<em>G</em> называют <em>автоморфным</em>.</p>

<p>Множество <em>R</em> называют <em>кольцом</em> если для множества определены две бинарные операции # и * такие что:<br>
1.&nbsp;Множество <em>R</em> является абелевой группой относительно операции # -- соответствует сложению.<br>
2.&nbsp;Операция * является ассоциативной.<br>
3.&nbsp;Выполняется закон дистрибутивности: <em>a</em>&nbsp;*&nbsp;(<em>b</em>&nbsp;#&nbsp;<em>c</em>)&nbsp;=&nbsp;<em>a</em>&nbsp;*&nbsp;<em>b</em>&nbsp;#&nbsp;<em>a</em>&nbsp;*&nbsp;<em>c</em>.</p>

<p>Если для группы определена операция сложения (<em>a</em>&nbsp;#&nbsp;<em>b</em>&nbsp;=&nbsp;<em>a</em>&nbsp;+&nbsp;<em>b</em>), то группу называют <em>аддитивной</em>. Единичный элемент аддитивной группы соответствует нулю. Обратный элементу <em>a</em> элемент аддитивной группы соответствует -<em>a</em>.</p>

<p>На операцию * можно накладывать дополнительные ограничения. Если в кольце присутствует единица, то кольцо называют <em>кольцом с единицей</em>. При выполнении закона коммутативности кольцо называют <em>коммутативным</em>.</p>

<p>Коммутативное кольцо называют <em>целостным</em> если его единица не равна нулю и <em>a</em>&nbsp;*&nbsp;<em>b</em>&nbsp;=&nbsp;0 только при <em>a</em>&nbsp;=&nbsp;0 или <em>b</em>&nbsp;=&nbsp;0.</p>

<p>Кольцо называют <em>телом</em> если кроме нуля в кольце существуют другие элементы и эти элементы образуют группу относительно операции *.</p>

<p>Наконец, коммутативное тело <em>F</em> называют <em>полем</em>.</p>

<p><em>Подгруппой</em>, <em>подкольцом</em>, <em>подполем</em> называют подмножества, сохраняющие соответствующие свойства.</p>

<p>Поле, не содержащее подполей, называют <em>простым</em>. Простым будет поле, порядок которого равен простому числу.</p>

<p>Подкольцо <em>I</em> кольца <em>R</em> называют его <em>идеалом</em> (<em>двухсторонним идеалом</em>) если для любой пары элементов <em>a</em> из <em>I</em> и <em>r</em> из <em>R</em> их произведение принадлежит <em>I</em>.</p>

<p>Подкольцо <em>R</em>/<em>I</em> классов вычетов по модулю идеала <em>I</em> из кольца <em>R</em> называют <em>факторкольцом</em> кольца <em>R</em> по идеалу <em>I</em>.</p>

<p>Наименьшее из натуральных чисел <em>n</em>, такое что для любого элемента <em>r</em> из кольца <em>R</em> выполняется равенство <em>n</em>&nbsp;*&nbsp;<em>r</em>&nbsp;=&nbsp;0, называют <em>характеристикой</em> кольца <em>R</em>.</p>

<p>Согласно теореме, каждое конечное целостное кольцо образует поле.</p>

<p>Согласно другой теореме, характеристикой конечного поля является простое число.</p>

<p>Поле <em>GF</em>(<em>p</em>) из целых чисел 0, 1 ... <em>p</em>&nbsp;-&nbsp;1, порожденное в результате отображения <em>f</em>:&nbsp;&integers;/<em>p</em>&nbsp;&rarr;&nbsp;<em>GF</em>(<em>p</em>), где &integers;/<em>p</em> -- факторкольцо множества целых чисел, в котором роль идеала играет простое число <em>p</em>, и <em>f</em>([<em>a</em>])&nbsp;=&nbsp;<em>a</em>, называют полем Галуа (Galois field) порядка <em>p</em>.</p>

<p>При вычислениях с элементами поля Галуа используют целочисленную арифметику с приведением по соответствующему модулю.</p>

<p>Одно и то же число можно записать самыми разными способами. Число можно рассматривать и как значение полинома.</p>

<p><em>Полиномом</em> (<em>многочленом</em>) одной переменной называют выражение:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<sub><em>n</em></sub><br>
<em>f</em>(<em>x</em>) = &sum; <em>a</em><sub><em>i</em></sub><em>x</em><sup><em>i</em></sup> = <em>a</em><sub><em>n</em></sub><em>x</em><sup><em>n</em></sup> + <em>a</em><sub><em>n-1</em></sub><em>x</em><sup><em>n-1</em></sup> + ... + <em>a</em><sub>0</sub> .<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<sup><em>i</em> = 0</sup></p>

<p>В случае <em>полинома над кольцом</em>, коэффициенты <em>a</em><sub><em>i</em></sub> соответствуют элементам кольца, а переменная <em>x</em> кольцу не принадлежит.</p>

<p>Два полинома <em>f</em>(<em>x</em>) и <em>g</em>(<em>x</em>) называют <em>равными</em> если равны их степени и равны коэффициенты при одинаковых степенях переменной.</p>

<p>Если старший коэффициент полинома равен единице, то полином называют <em>приведенным</em>.</p>

<p><em>Тривиальными</em> делителями полинома называют сам полином и полином равный 1.</p>

<p>Полином над полем <em>F</em> называют <em>неприводимым</em> над этим полем если полином допускает только тривиальное разложение, то есть у полинома нет нетривиальных делителей из <em>F</em> (с точностью до домножения на ненулевую константу).</p>

<p>Для практического применения полей Галуа в компьютерных системах необходимо перейти от скалярного представления к векторному.</p>

<p>Расширенное поле Галуа <em>GF</em>(<em>p</em><sup><em>n</em></sup>) можно рассматривать как векторное пространство, где простое число <em>p</em> является характеристикой поля и соответствует количеству состояний разряда вектора, а <em>n</em> является степенью поля над его простым подполем и соответствует количеству разрядов вектора.</p>

<p>Поскольку в обычных компьютерных системах разряды регистров бинарные, то наибольший интерес представляют поля <em>GF</em>(2<sup><em>n</em></sup>).</p>

<p>Чтобы расширенное поле было полноценным, должны быть определены операции.</p>
<p>Сложение бинарных векторов (совпадает с вычитанием) проблему не представляет и соответствует поразрядной операции xor.</p>
<p>А вот с умножением и делением дела обстоят значительно сложнее. Скалярное произведение не подходит, так как его результат может «выйти» за пределы поля. Векторное произведение определено только для трехразрядных векторов. Полиномиальное представление так же с ходу не решает проблему, так как произведение полиномов опять же «выводит» за пределы поля. Для обеспечения конечности поля Галуа, полученный в результате произведения полином нужно привести. Это достигают путем деления на некий выбранный полином степени <em>n</em>. Ясно, что выбирать можно разные полиномы. Выбор другого полинома приведет к другим результатам умножения и, соответственно, к другому полю <em>GF</em>(<em>p</em><sup><em>n</em></sup>). Выбранный для построения поля Галуа полином называют порождающим (образующим).</p>
<p>Деление векторов в математике не известно. После перехода на язык полиномов, опять же для обеспечения конечности поля Галуа, деление всегда должно быть безостаточным. Деление можно представить как умножение полинома-делимого на полином, обратный делителю. При этом для достижения цели, на основании математических выкладок, необходимо ввести еще одно ограничение: порождающий полином должен быть неприводимым по модулю <em>p</em> (например, если <em>p</em>&nbsp;=&nbsp;2 и <em>n</em>&nbsp;=&nbsp;4, то полином <em>x</em><sup>4</sup>&nbsp;+&nbsp;1 (число 17) не подходит, так как <em>x</em><sup>4</sup>&nbsp;+&nbsp;1&nbsp;&equiv;&nbsp;(<em>x</em><sup>2</sup>&nbsp;+&nbsp;1)<sup>2</sup>&nbsp;(mod&nbsp;2)).</p>
<p>Возведение в степень обладает цикличностью.</p>

<p>Считается, что начало помехоустойчивому кодированию положила теорема Шеннона, утверждающая что любой дискретный канал связи имеет конечную пропускную способность и этот канал может быть задействован для передачи информации со сколь угодно большой степенью достоверности, не смотря на наличие помех.</p>

<div align="center">
<img src="lk04.02.01.bmp">
<br>
Рисунок -- Модель канала связи
</div>

<p>Передаваемое сообщение разбивается на блоки фиксированного размера <em>a</em> из <em>k</em> битов <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub> ... <em>a</em><sub><em>k</em></sub>. Кодер выполняет функцию <em>f</em>, называемую схемой кодирования, и тем самым преобразует вектор <em>a</em> в вектор <em>c</em> из <em>n</em> &gt; <em>k</em> битов <em>c</em><sub>1</sub>, <em>c</em><sub>2</sub> ... <em>c</em><sub><em>n</em></sub>, называемый кодовым словом. В процессе пересылки кодового слова по каналу связи на него накладывается вектор ошибок <em>e</em>, в котором единичные биты соответствуют искажениям. После применения декодером схемы декодирования <em>g</em> получается вектор <em>a'</em>, в идеале совпадающий с исходным вектором <em>a</em>.</p>

<p>Подобная схема кодирования является избыточной. На практике всегда ищут компромисс между степенью обеспечения достоверности при передаче и вычислительной сложностью кодов (что в первую очередь отражается на скорости декодирования).</p>

<p>В КС множество кодовых слов получается из множества исходных слов как отображение из конечного поля <em>GF</em>(2<sup><em>k</em></sup>) в конечное поле <em>GF</em>(2<sup><em>n</em></sup>).</p>

<p>При более простых схемах кодирования, в кодовом слове сначала располагаются биты входного сообщения, называемые <em>информационными</em>, а за ними дополнительные биты, называемые <em>проверочными</em>: <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub> ... <em>a</em><sub><em>k</em></sub>, <em>c</em><sub><em>k</em>+1</sub>, <em>c</em><sub><em>k</em>+2</sub> ... <em>c</em><sub><em>n</em></sub>. В более сложных случаях проверочные биты чередуются с информационными.</p>

<p>Схему кодирования удобно представлять в матричном виде.</p>

<div align="center">
<img src="lk04.02.02.bmp">
<br>
Рисунок -- Пример построения проверочной матрицы
</div> 

<p>Видно, что проверочные уравнения образуют систему линейных уравнений. Следовательно, отображение <em>f</em> (схема кодирования) является линейным.</p>

<p>Если <em>H</em> -- матрица размером (<em>n</em>&nbsp;-&nbsp;<em>k</em>)&nbsp;&Cross;&nbsp;<em>n</em> ранга <em>n</em>&nbsp;-&nbsp;<em>k</em> и <em>H</em>&nbsp;<em>c</em><sup>T</sup>&nbsp;=&nbsp;0, то множество всех <em>n</em>-разрядных векторов, входящих в поле <em>GF</em>(2<sup><em>n</em></sup>) (в общем случае <em>GF</em>(<em>p</em><sup><em>n</em></sup>)), называют <em>линейным (n,k)-кодом</em> (в математическом смысле) длины <em>n</em> и размерности <em>k</em>. А матрицу <em>H</em> называют <em>проверочной</em>.</p>

<p>Линейный код по-другому называют <em>групповым</em>, так как множество кодовых слов можно рассматривать как подгруппу в отношении поля <em>GF</em>(2<sup><em>n</em></sup>).</p>

<p>Линейный код называеют <em>систематическим</em> (<em>разделенным</em>) если расположение проверочных битов известно (не важно где они находятся), то есть если <em>H</em>&nbsp;=&nbsp;[<em>A</em>&nbsp;&nbsp;&nbsp;<em>I</em><sub><em>n</em>&nbsp;-&nbsp;<em>k</em></sub>], где <em>A</em> -- матрица размером (<em>n</em>&nbsp;-&nbsp;<em>k</em>)&nbsp;&Cross;&nbsp;<em>k</em>, а <em>I</em><sub><em>n</em>&nbsp;-&nbsp;<em>k</em></sub> -- единичная матрица ранга <em>n</em>&nbsp;-&nbsp;<em>k</em>.</p>

<p>Матрицу <em>G</em>&nbsp;=&nbsp;[<em>I</em><sub><em>k</em></sub>&nbsp;&nbsp;&nbsp;-<em>A</em><sup>T</sup>] размером <em>k</em>&nbsp;&Cross;&nbsp;<em>n</em> называют <em>кодирующей</em> (<em>порождающей</em>) матрицей систематического кода.</p>

<p>Кодирующая и проверочная матрицы связаны следующим образом: <em>G</em><em>H</em><sup>T</sup>&nbsp;=&nbsp;0.</p>

<p>Самыми примитивными из линейных кодов являются подсчет контрольной суммы и дублирование информационных символов.</p>

<p>Перед выбором того либо иного помехоустойчивого кода всегда нужно определиться, что требуется от кода. Если перефразировать, то нужно ответить на два вопроса:<br>
1.&nbsp;Сколько бинарных ошибок код должен обнаруживать.<br>
2.&nbsp;Сколько бинарных ошибок код должен исправлять.<br>
Исправлять ошибки значительно сложнее, чем обнаруживать. Применительно ко многим кодам, исправление ошибки подразумевает нахождение ее позиции.</p>

<p>В общем случае ошибки носят случайный характер. Множественные ошибки могут быть взаимозависимыми, то есть образовывать <em>модули ошибок</em>. Если ошибки расположены рядом, то они образуют <em>пакет ошибок</em> (частный случай модуля).</p>

<p>Число координат (позиций), которыми два вектора <em>x</em> и <em>y</em> различаются называют <em>расстоянием Хэмминга</em> -- <em>d</em>(<em>x</em>,<em>y</em>). Число ненулевых позиций вектора <em>x</em> называют <em>весом Хэмминга</em> -- <em>w</em>(<em>x</em>). Видно, что расстояние Хэмминга показывает количество возникших ошибок.</p>

<p>Для увеличения корректирующей способности кода следует стремиться увеличивать расстояния между кодовыми словами. При этом минимальное расстояние <em>d</em><sub>min</sub> называют <em>кодовым</em> и оно является очень важной характеристикой помехоустойчивого кода.</p>

<p>Согласно теореме, для того чтобы линейный код исправлял <em>t</em> ошибок должно выполняться условие: <em>d</em><sub>min</sub>&nbsp;&ge;&nbsp;2<em>t</em>&nbsp;+&nbsp;1.</p>

<p>Для того, чтобы линейный код обнаруживал <em>t</em> ошибок должно выполняться условие: <em>d</em><sub>min</sub>&nbsp;&ge;&nbsp;<em>t</em>&nbsp;+&nbsp;1.</p>

<div align="center">
<img src="lk04.02.03.bmp">
<br>
Рисунок -- Визуальное представление влияния кодового расстояния на обнаружение и исправление ошибок
</div>

<p>Для того чтобы линейный код имел <em>d</em><sub>min</sub>&nbsp;&ge;&nbsp;<em>s</em>&nbsp;+&nbsp;1, необходимо и достаточно, чтобы любые <em>s</em> столбцов его проверочной матрицы были линейно независимы.</p>

<p>Способность того или иного кода сохранять свои характеристики зависит и от количественного соотношения информационных и проверочных символов. В теории помехоустойчивого кодирования определяют так называемые верхние и нижние границы кодов.</p>

<p>Существуют три основных способа декодирования:<br>
1.&nbsp;По минимуму расстояния.<br>
2.&nbsp;По синдрому (по лидеру смежного класса).<br>
3.&nbsp;Мажоритарное:<br>
--&nbsp;с разделенными проверками;<br>
--&nbsp;с &lambda;-проверками;<br>
--&nbsp;с квазиразделенными проверками.</p>

<p>За достаточно длительную историю развития прикладной теории кодирования, как науки, было придумано очень много помехоустойчивых кодов.</p>

<p>Основные группы помехоустойчивых кодов:<br>
1.&nbsp;Линейные коды, в том числе: коды Хэмминга, циклические коды, БЧХ-коды (коды Боуза-Чоудхури-Хоквингема), РМ-коды (коды Рида-Маллера), итеративные коды, коды на основе матриц Адамара, симплексные коды и некоторые другие.<br>
2.&nbsp;Коды для контроля модульных и пакетных ошибок, в том числе: РС-коды (коды Рида-Соломона), низкоплотные модульные коды, векторные модульные коды, итеративные модульные коды и некоторые другие.<br>
3.&nbsp;Сверточные коды.<br>
4.&nbsp;Арифметические коды.<br>
5.&nbsp;Низкоскоростные коды, в том числе: коды максимальной длины, нелинейные коды, D-коды и некоторые другие.</p>

<p>Для изучения в рамках данной дисциплины выбраны два кода:<br>
1.&nbsp;Код Хэмминга -- Hamming сode.<br>
2.&nbsp;Циклический код -- CRC (Cyclic Redundancy Code).</p>

<p>Бинарным кодом Хэмминга называют код длины <em>n</em>&nbsp;=&nbsp;2<em>m</em>&nbsp;-&nbsp;1, <em>m</em>&nbsp;&ge;&nbsp;2 с проверочной матрицей <em>H</em> размером <em>m</em>&nbsp;&Cross;&nbsp;(2<em>m</em>&nbsp;-&nbsp;1), в которой столбцы соответствуют записи 1, 2 ... 2<sup><em>m</em></sup>&nbsp;-&nbsp;1 в двоичной системе счисления.</p>

<p>Код Хэмминга позволяет исправлять одиночную ошибку и обнаруживать множественные ошибки.</p>

<p>Циклические коды являются особо выделяемой подгруппой линейных кодов.</p>

<p>Циклическим кодом называют линейный код, удовлетворяющий дополнительному условию: если вектор <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub> ... <em>a</em><sub><em>n</em>-1</sub> является кодовым словом, то и его циклический сдвиг <em>a</em><sub><em>n</em>-1</sub>, <em>a</em><sub>0</sub> ... <em>a</em><sub><em>n</em>-2</sub> так же является кодовым словом.</p>

<p>Циклический код позволяет исправлять одну и более ошибок и обнаруживать множественные ошибки (зависит от параметров).</p>

<p>Базовая идея циклического кодирования состоит в том, чтобы в качестве проверочных битов передавать остаток от деления информационных битов на некоторое выбранное число. После приема снова выполняется деление уже возможно искаженных информационных битов на то же самое число и сравниваются остатки. Если остатки совпадают, то данные с определенной вероятностью приняты без ошибок.</p>

<p>На практике же деление выполняется по правилам арифметики полей Галуа, то есть без учета переносов. Информационные биты, то есть делимое, соответствуют информационному полиному. Делитель соответствует порождающему (образующему) полиному. Частное в процессе кодирования не используется и поэтому «отбрасывается». Для того чтобы максимально разнообразить остатки в качестве порождающего полинома должен выбираться неприводимый полином.</p>

<p>Существуют два подхода к реализации циклического кода на стороне приемника:<br>
1.&nbsp;Согласно базовой идее, описанной выше.<br>
2.&nbsp;На порождающий полином делится все принятое кодовое слово. Если ошибок не произошло, то остаток будет нулевым.<br>
Оба подхода равноценны.</p>

</div>

</BODY>
</HTML>
