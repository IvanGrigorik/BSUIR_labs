<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">

<title>Лекция</title>
<style type="text/css">
 body {font-family: Arial, sans-serif;}
 .c {font-family: "Courier New", Courier, monospace}
</style>

</HEAD><BODY>

<div align="justify">

<p>&nbsp;</p>
<div align="center">
<p><strong>ПАКЕТНАЯ ПЕРЕДАЧА ДАННЫХ</strong></p>
</div>
<p>&nbsp;</p>

<p>Исторически так сложилось, что компьютерные сети имеют последовательную природу. Объяснить это можно тем, что реализовать передачу данных на сравнительно больши'е расстояния в параллельном виде значительно сложнее, чем в последовательном. Между станциями данные передаются по последовательным каналам, а внутри станций обрабатываются параллельно.</p>

<p>Для именования порции информации, передаваемой по каналам компьютерных (и не только компьютерных) сетей, используют обобщенный термин <em>пакет</em> (packet). Пакет содержит последовательно сформированные станцией-передатчиком <em>поля</em> (fields), предназначенные для их интерпретации в станции-приемнике. В общем случае, пакеты могут быть самыми разнообразными (как по структуре, так и по длине), но подавляющее большинство пакетов подпадают под типовую структуру.</p>

<div align="center">
<img src="lk03.01.bmp">
<br>
Рисунок -- Структура типового пакета КС
</div>

<p>Назначение полей:<br>
1.&nbsp;Flag -- флаг, точнее, флаг начала пакета -- позволяет определить начало пакета.<br>
2.&nbsp;Destination Address -- адрес назначения -- позволяет указать станцию, для которой предназначен пакет.<br>
3.&nbsp;Source Address -- адрес источника -- позволяет указать станцию, сгенерировавшую пакет.<br>
4.&nbsp;Other Fields -- прочие поля -- специфические поля (в том числе и специфические флаги) определенной реализации.<br>
5.&nbsp;Data -- данные -- «полезное» наполнение пакета.<br>
6.&nbsp;FCS (Frame Check Sequence) -- контрольная сумма -- позволяет проверить целостность пакета.</p>

<p>Часть пакета, включающую поля, расположенные до начала данных, принято называть <em>заголовком</em> (header) пакета, после данных -- <em>хвостовиком</em> (trailer).</p>

<p>Обычно в байт-ориентированных реализациях длина пакета кратна восьми битам, то есть пакет состоит из так называемых <em>октетов</em> (octets).</p>

<p>Все поля в составе любого пакета можно условно разделить на полезные и служебные. <em>Полезная нагрузка</em> (payload) заключается в собственно данных. Но следует понимать, что вкладываемая в качестве данных информация может носить служебный характер. В некоторых пакетах поле данных не предусмотрено вообще. Сколько дополнительного трафика порождается в связи с наличием служебных полей оценивают как overhead.</p>

<p>В соответствии с концепцией модели OSI, соседние уровни абстрагированы друг от друга. Поэтому вполне закономерно, что на каждом уровне работают со своими структурами данных. При продвижении информации между уровнями возникает необходимость в преобразованиях структур данных. Преобразования выражаются в инкапсуляции и декапсуляции. Под <em>инкапсуляцией</em> (encapsulation) в КС понимают вкладывание пакета определенного вышестоящего уровня в поле данных пакета смежного нижестоящего уровня в процессе подготовки к передаче, то есть при продвижении сверху вниз. Под <em>декапсуляцией</em> (decapsulation) понимают обратное действие после приема, то есть при продвижении снизу вверх.</p>

<div align="center">
<img src="lk03.02.bmp">
<br>
Рисунок -- Инкапсуляция пакетов
</div>

<p>Функционал любого из вышестоящих уровней «знает», какие нижестоящие ресурсы ему необходимы и чем он «располагает». Поэтому процесс инкапсуляции не доставляет трудностей. А вот функционал нижестоящего уровня при разборе полученных пакетов заранее не знает, какой из вышестоящих подсистем передавать эти пакеты. Проблему решают введением в структуру пакета служебного поля, в котором записывается код протокола вышестоящего уровня.</p>

<p>Важной особенностью инкапсуляции является то, что в большинство реализаций заложена возможность передавать пакеты, относящиеся к некоторому протоколу некоторого уровня (например, сетевого), вкладывая их в пакеты другого протокола того же уровня, то есть организовывать <em>туннелирование</em> (tunneling).</p>

<p>Инкапсуляция имеет еще ряд проявлений.</p>

<p>Если при выполнении инкапсуляции данные некоторого уровня не помещаются в поле отведенной длины, то можно прибегнуть к <em>фрагментации</em> (fragmentation) -- разбить данные на фрагменты и передать цепочку пакетов. Принимающая сторона будет вынуждена выполнить <em>дефрагментацию</em> (defragmentation). Поле, отвечающее за длину поля данных, может быть не предусмотрено. Если длина поля данных фиксирована, а данных не хватает, то возникает необходимость в автодополнении (например, нулями).</p>

<p><em>Перемежение</em> (interleaving) позволяет «распараллелить» пересылку пакетов или их фрагментов и заключается в одновременном задействовании нескольких каналов. Особенно это применимо в низкоскоростных СрПД.</p>

<p>Фрагментация (при наличии альтернативных путей в СПД) и перемежение могут привести к «перемешиванию» пакетов и, как следствие, разрушению сообщения. Контроль за порядком фрагментов может быть возложен как на протокол подверженного фрагментации уровня, так и протокол вышестоящего уровня.</p>

<p>Несмотря на целостность уровней, вышестоящие уровни зависят от нижестоящих. Но степень зависимости различается. Иногда требуется просто наличие поддержки одного из нижестоящих протоколов, иногда требуется поддержка конкретного нижестоящего протокола.</p>

<p>Названия структурных единиц передаваемой информации в привязке к уровням модели OSI:<br>
L1 -- сигналы (signals).<br>
L2 -- <em>кадры</em> (frames).<br>
L3 -- собственно <em>пакеты</em> (packets).<br>
L4 + L5 -- <em>сегменты</em> (segments).<br>
L6 + L7 -- <em>сообщения</em> (messages).</p>

<p>Фундаментальная задача СПД заключается в том, чтобы правильно передать сообщение.</p>

<p>Пакеты «возникают» начиная со второго уровня, хотя собственно пакетами традиционно называют пакеты, относящиеся к третьему уровню.</p>

<p>Первый и второй уровни часто совмещают в рамках аппаратных технологий.</p>

<p>Четвертый и пятый уровни, равно как шестой и седьмой уровни, обычно реализуют «неразрывно» в рамках программных технологий.</p>

<p>Для обобщенной ссылки на порцию данных, над которой оперируют на некотором уровне, иногда используют термин PDU (Protocol Data Unit).</p>

<p>Понятно, что для правильной интерпретации пакета нужно его считать из канала полностью, причем с соблюдением последовательности. Если бы взаимодействующие станции работали бесконечно и находились в соответствующей степени готовности, то это не составляло бы особого труда. Но, поскольку станция-приемник может подключиться к каналу (да и вообще начать работать) в произвольный момент времени, возникает проблема, связанная с распознаванием флага начала пакета. Флаг начала пакета представляет собой зарезервированную цифровую последовательность, которая собственно позволяет станции-приемнику определить начало пакета. Проблема заключается в том, что такая же последовательность вполне может встретиться в пакете и после флага начала. Следовательно, возникает задача обеспечения уникальности флага начала пакета, то есть исключения этой последовательности из оставшейся части пакета.</p>

<p>Это достигается за счет действия, заключающегося в модификации следующей за флагом цифровой последовательности, которое в бит-ориентированных системах называют <em>бит-стаффингом</em> (bit stuffing), а в байт-ориентированных -- <em>байт-стаффингом</em> (byte stuffing).</p>

<p>При бит-стаффинге совпадающая с флагом последовательность разбивается с помощью вставки дополнительно бита с соответствующим значением. Применение бит-стаффинга приводит к увеличению длины пакета. Теоретически, с целью уменьшения связанных с бит-стаффингом «издержек», следует стремиться к минимизации количества вставок: разбивающий бит нужно вставлять после наиболее длинной уникальной подпоследовательности в флаговой последовательности.</p>

<p>Классическим флагом начала пакета является байт со значением 01111110b (7Eh). Оптимальная реализация бит-стаффинга при использовании классического флага проиллюстрирована на рисунке.</p>

<div align="center">
<img src="lk03.03.bmp">
<br>
Рисунок -- Пример реализации бит-стаффинга
</div>

<p>На передающей стороне после нуля и шести единиц всегда вставляется седьмая единица, а на принимающей стороне единица после нуля и шести единиц всегда удаляется.</p>

<p>Цель байт-стаффинга полностью совпадает с целью бит-стаффинга. В сравнении с алгоритмами бит-стаффинга, алгоритмы байт-стаффинга манипулируют байтами, являются более сложными и более «затратными», но при программировании они позволяют избежать битовых операций (бит-стаффинг, в отличие от байт-стаффинга, обычно реализуют аппаратно).</p>

<div align="center">
<img src="lk03.04.bmp">
<br>
Рисунок -- Пример реализации байт-стаффинга
</div>

<p>Единственным способом обеспечения уникальности флагового байта является замена совпадающего с ним байта на некий выбранный другой. Но возникает вопрос, как принимающая сторона отличит замененный байт от такого же незамененного. Решением является применение так называемого ESC-символа. Наличие ESC-символа говорит станции-приемнику о факте замены, а следующий за ESC-символом символ -- код замены позволяет определить какая замена была осуществлена. Байт-стаффингу можно подвергать целые группы символов.</p>

<p>Бит-стаффинг обычно применяют при задействовании синхронных СрПД, а байт-стаффинг -- асинхронных. Примерами технологий могут служить SDLC, HDLC, ISDN и другие (многие поддерживают как синхронные так и асинхронные СрПД). Примером протокола может служить PPP.</p>

<p>Следует отметить, что на практике (например, применительно к HDLC) бит-стаффинг выполняется вставкой нуля после пяти единиц.</p>

</div>

</BODY>
</HTML>
