<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">

<title>Лекция</title>
<style type="text/css">
 body {font-family: Arial, sans-serif;}
 .c {font-family: "Courier New", Courier, monospace}
</style>

</HEAD><BODY>

<div align="justify">

<p>&nbsp;</p>
<div align="center">
<p><strong>МЕТОДЫ ВЗАИМОДЕЙСТВИЯ В ЗВЕНЕ СЕТИ ПЕРЕДАЧИ ДАННЫХ</strong></p>
</div>
<p>&nbsp;</p>

<p>При формировании полномасштабной сети, то есть при объединении разрозненных физических сегментов в СПД той или иной сложности, возникает ряд специфических задач, направленных на оптимизацию взаимодействия между абонентами.</p>

<p>Упомянутые задачи решают на третьем и четвертом уровнях модели OSI.</p>

<p>Новые задачи обусловлены серьезными отличиями процессов передачи-приема пакета в пределах сегмента и между сегментами. Основные отличия заключаются в необходимости ретрансляций пакетов, а так же в возможном наличии альтернативных путей.</p>

<p>Одним из ключевых терминов транспортного уровня является термин <em>соединение</em> (connection). По сути дела, понятие соединения связано с понятием готовности. Если абоненты находятся в состоянии «нормальной готовности» передавать или принимать данные, то считают, что между ними установлено соединение. С учетом абстрагирования от более низких уровней модели OSI и инкапсуляции, соединение может быть выражено неявно.</p>

<p>Нужно отличать <em>виртуальные соединения</em> (virtual connections) от <em>физических соединений</em> (physical connections). Абоненты-программы физически (явно) соединены быть не могут. Следовательно, применительно к ним, соединения являются сугубо виртуальными.</p>

<p>Следует также учитывать, что нормальная готовность может рассматриваться в двух ракурсах:<br>
1.&nbsp;Организация взаимодействия абонентов-программ.<br>
2.&nbsp;Настройка задействованного промежуточного оборудования.<br>
В первом случае речь идет о собственно виртуальных соединениях транспортного уровня, во втором -- о <em>виртуальных цепях</em> (virtual circuits) сетевого или канального уровней.</p>

<p>В свою очередь, виртуальные цепи бывают:<br>
1.&nbsp;PVCs (Permanent Virtual Circuits) -- <em>выделенные виртуальные цепи</em>.<br>
2.&nbsp;SVCs (Switched Virtual Circuits) -- <em>коммутируемые виртуальные цепи</em> (в отечественной литературе иногда называют <em>виртуальными вызовами</em>).</p>

<p>Термин <em>виртуальный канал</em> (virtual channel) может в равной степени подходить как к виртуальным соединениям, так и к виртуальным цепям.</p>

<p>При разговоре о соединениях невозможно обойти стороной вопрос о надежности. Существуют два способа организации взаимодействия:<br>
1.&nbsp;Без гарантированной доставки -- в СПД предпринимаются определенные усилия по доставке пакетов, но при этом ничего не гарантируется (при необходимости, соответствующий контроль возлагается на программы-абоненты).<br>
2.&nbsp;С гарантированной доставкой -- алгоритм работы транспортной службы гарантирует доставку пакетов (программы-абоненты могут не контролировать наличие и очередность пакетов).<br>
Однако, соединение без гарантированной доставки практического смысла не имеет. Поэтому наличие соединения как правило говорит о надежности.</p>

<p>В общем случае, контроль передачи информации посредством СПД предотвращает не только потерю пакетов, но и искажение их содержимого. Отсутствие соединения не означает, что защита от сбойных пакетов отсутствует.</p>

<p>Простейшим подходом к обеспечению контроля доставки информационных пакетов является применение метода, который обобщенно можно назвать методом <em>запросов-подтверждений</em> (requests/acknowledges). Метод предполагает некоторое разнообразие и заключается в том, что вводят специальные служебные пакеты двух типов. Пакет-запрос используется при получении права принять или передать полезные данные, а также собственно при запросе данных. Пакет-подтверждение (в отечественной литературе часто называют <em>квитанцией</em>) передается в ответ на пакет-запрос или после приема полезных данных.</p>

<p>Кроме того, при реализации метода запросов-подтверждений следует учитывать следующие обстоятельства:<br>
--&nbsp;инициатором взаимодействия может быть передатчик либо приемник информационных пакетов;<br>
--&nbsp;контроль может осуществляться передатчиком либо приемником, либо передатчиком и приемником совместно;<br>
--&nbsp;запросы либо подтверждения могут отсутствовать вообще;<br>
--&nbsp;запросы могут комбинироваться с подтверждениями;<br>
--&nbsp;запрашиваться и подтверждаться может все сообщение либо каждый из пакетов;<br>
--&nbsp;подтверждаться могут не только информационные, а и служебные пакеты;<br>
--&nbsp;квитанции могут быть как положительными, так и отрицательными;<br>
--&nbsp;факт потери пакета может определяться и обрабатываться по-разному.</p>

<p>Таким образом, не смотря на сохранение идеологии, практические реализации метода запросов-подтверждений могут сильно различаться.</p>

<div align="center">
<img src="lk09.01.bmp">
<br>
Рисунок -- Пример взаимодействия методом запросов-подтверждений
</div>

<p>На практике, метод запросов-подтверждений невозможно реализовать без одного существенного дополнения.</p>

<p>Функционирование механизма запросов-подтверждений подразумевает ожидание определенных событий. Ожидание, в любом случае, не должно затягиваться до бесконечности. Ограничение ожидания во времени достигается за счет применения тайм-аута (time-out). После передачи некоторого служебного или информационного пакета, требующего подтверждения, запускается таймер с обратным отсчетом. Если в течение заданного интервала времени соответствующая квитанция не приходит, то пакет считается утерянным и передается повторно (retransmission). Если квитанция не приходит снова и снова, то после некоторого конечного количества попыток дальнейшая передача считается бесперспективной и прекращается.</p>

<div align="center">
<img src="lk09.02.bmp">
<br>
Рисунок -- Пример взаимодействия с учетом тайм-аута
</div>

<p>Следует учитывать, что:<br>
--&nbsp;теряться могут как информационные пакеты, так и квитанции и пакеты-запросы;<br>
--&nbsp;если квитанция приходит позже наступления тайм-аута, то этот факт приравнивается к ее потере;<br>
--&nbsp;оптимальное время ожидания квитанций, применительно к некоторой СПД, зависит от ее особенностей.</p>

<p>В случае, когда СПД загружена незначительно, а взаимодействующие абоненты расположены далеко друг от друга, задействование классического механизма запросов-подтверждений приводит к неэффективному использованию ресурсов. Время, затрачиваемое на ожидание квитанций, становится недопустимо большим в сравнении с временем, затрачиваемым на передачу полезных данных. Оптимизировать обмен позволяет применение оконного (window) метода, суть которого состоит в том, что до перехода к ожиданию квитанций передается не один, а несколько пакетов.</p>

<p>Выделяют два основных критерия классификации оконных методов.</p>

<p>Исходя из количества пакетов, передаваемых в окне, оно может быть:<br>
1.&nbsp;<em>Статическим</em> (static) -- неизменяемый размер окна заложен в протокол или устанавливается на весь сеанс обмена.<br>
2.&nbsp;<em>Динамическим</em> (dynamic) -- размер окна может изменяться (увеличиваться или уменьшаться) в процессе передачи сообщения.</p>

<p>Исходя из способа обработки очереди пакетов, окно может быть:<br>
1.&nbsp;<em>Фиксированным</em> (fixed) -- перед формированием следующего окна текущее должно быть полностью «закрыто», то есть должны быть приняты все необходимые квитанции.<br>
2.&nbsp;<em>Скользящим</em> (sliding) -- существует возможность сдвигать окно относительно последовательности пакетов.</p>

<p>При реализации оконного метода следует учитывать следующие дополнительные обстоятельства:<br>
--&nbsp;должен быть установлен начальный размер окна;<br>
--&nbsp;нужна нумерация пакетов в том или ином виде;<br>
--&nbsp;подтверждаться может как все окно, так и каждый из пакетов;<br>
--&nbsp;размером окна может управлять как передатчик, так и приемник;<br>
--&nbsp;размером окна можно управлять посредством служебных полей, в том числе и в информационных пакетах;<br>
--&nbsp;окно, с которым работает передатчик, может отличаться от окна, с которым работает приемник;<br>
--&nbsp;иногда важен порядок доставки пакетов.</p>

<p>С точки зрения реализации, наиболее простым является статическое окно фиксированного размера.</p>

<div align="center">
<img src="lk09.03.bmp">
<br>
Рисунок -- Пример статического окна
</div>

<p>Основной его недостаток состоит в отсутствии возможности адаптации к изменениям в СПД.</p>

<p>Первым вариантом усложнения является переход к динамическому окну.</p>

<div align="center">
<img src="lk09.04.bmp">
<br>
Рисунок -- Пример динамического окна
</div>

<p>Динамическое окно позволяет успешно адаптироваться к изменениям в СПД. При увеличении загруженности окно целесообразно сужать, а при снижении -- расширять.</p>

<p>Вторым вариантом усложнения является переход к скользящему окну.</p>

<div align="center">
<img src="lk09.05.bmp">
<br>
Рисунок -- Пример скользящего окна
</div>

<p>Скользящее окно, особенно в сочетании с динамическим, позволяет ускорить адаптацию к топологическим и другим изменениям в СПД.</p>
Таким образом, наиболее сложным является динамическое скользящее окно.

<p>Классической реализацией оконного метода является оконный механизм протокола транспортного уровня TCP (Transmission Control Protocol) (основное RFC -- RFC&nbsp;793). Протокол обеспечивает установление надежного соединения между сугубо пользовательскими или другими видами приложений, то есть доставка данных в правильном порядке гарантируется.</p>

<p>В стандарте TCP описано динамическое скользящее окно.</p>

<p>TCP соответствует клиент-серверной модели.</p>

<p><em>Сокет</em> (socket) -- это «привязка» к виртуальному каналу, соединяющему между собой два взаимодействующих сетевых процесса, с точки зрения одного (любого) из этих процессов, причем с учетом всех трех уровней адресации.</p>

<div align="center">
<img src="lk09.06.bmp">
<br>
Рисунок -- TCP-соединение
</div>

<p>&nbsp;</p>

<div align="center">
<img src="lk09.07.bmp">
<br>
Рисунок -- Структура системы TCP
</div>

<p>Применительно к каждому TCP-соединению нужно выделять приложение, производящее или потребляющее сетевые данные, и TCP-процесс, предоставляющий коммуникационные услуги (например, специальный драйвер ОС). Синхронизировать работу приложения и TCP-процесса можно только с помощью буферизации. TCP-интерфейс, которым пользуется приложение, состоит из примитивов для работы с буфером, позволяющих контролируя записывать или считывать данные. Доступ к буферу имеет и TCP-процесс, который отслеживает наполнение буфера и, используя ресурсы более низких уровней, организует прием или передачу данных.</p>

<p>Предназначенное для передачи сообщение разбивается на сегменты.</p>

<p>Минимальной учитываемой в окне единицей данных является октет, то есть байт. Все байты сообщения последовательно нумеруются так называемыми последовательными номерами -- SNs (Sequence Numbers). Нумерация начинается с некоторого начального последовательного номера -- ISN (Initial Sequence Number), который как правило не равен нулю, а генерируется реализациями случайно (например, на основе текущего времени) для того чтобы лучше управлять соединениями (например, после их ненормальных завершений). Принято, что сам ISN в нумерацию байтов не включается, то есть номер первого байта сообщения больше ISN на единицу.</p>

<p>Номером сегмента является SN первого байта данных в нем. По разным понятным причинам длина сегмента может варьировать, но она имеет ограничение. Поэтому важное значение имеет конфигурационный параметр MSS (Maximum Segment Size) -- максимальная длина сегмента (по умолчанию 536&nbsp;байтов).</p>

<div align="center">
<img src="lk09.08.bmp">
<br>
Рисунок -- Пример сегментации TCP-сообщения
</div>

<p>В стандарте выделяют несколько видов окон, которые нужно различать.</p>

<p>Благодаря гибкости протокола, передающий и принимающий TCP-процессы работают с разными окнами, то есть, в первую очередь, следует отдельно рассматривать окно передачи (send window) и окно приема (receive window).</p>

<div align="center">
<img src="lk09.09.bmp">
<br>
Рисунок -- Организация буфера передачи TCP
</div>

<p>Передающее приложение последовательно, «порциями», записывает блоки байтов сообщения, возможно разной длины, в буфер передачи. Длина сообщения и размер буфера -- это вещи независимые, они почти всегда различаются. TCP-процесс формирует из имеющихся в буфере данных соответствующее количество сегментов и последовательно отправляет их. В любой момент времени текущее окно (current window) передачи имеет некоторый установленный размер и характеризуется тем, что все попадающие в него сегменты с данными можно передавать без ожидания подтверждений. Его правая (на рисунке) граница совпадает с правой границей буфера и скользит налево относительно последовательности сегментов с данными по мере поступления и упорядочивания подтверждений. Переданные, но неподтвержденные сегменты с данными продолжают оставаться в буфере, так как возможно потребуется их повторная передача. Левая граница «привязана» к правой в соответствии с размером текущего окна. Но поскольку размер подвержен динамической коррекции, положение левой границы относительно правой постоянно изменяется.</p>

<p>Область текущего окна передачи за вычетом переданных, но неподтвержденных сегментов с данными, является доступным окном (useable равно effective window). TCP-процесс должен последовательно отправить все сегменты с данными, попавшие в эту область. Если размер текущего окна передачи равен нулю, то передача приостанавливается полностью.</p>

<div align="center">
<img src="lk09.10.bmp">
<br>
Рисунок -- Организация буфера приема TCP
</div>

<p>На другой стороне соединения, возможно уже разупорядоченные при преодолении СПД сегменты поступают в буфер приема (размер может не совпадать с размером буфера передачи). При этом они размещаются там согласно своим номерам.</p>

<p>Текущее окно приема охватывает часть буфера, в которой можно размещать еще неупорядоченные сегменты с данными. Как и текущее окно передачи, в любой момент времени оно так же имеет некоторый определенный размер. Левая (на рисунке) граница текущего окна приема совпадает с левой границей буфера. Правая граница проходит слева за последним упорядоченным сегментом с данными и поэтому динамически меняет свое положение относительно левой границы. По мере считывания принимающим приложением упорядоченных байтов из буфера окно скользит относительно последовательности сегментов с данными. Если размер текущего окна приема равен нулю, а сегменты с данными продолжают поступать, то возникает переполнение.</p>

<p>Вполне закономерно, что именно на принимающий TCP-процесс, как на более подверженный влиянию недетерминированности СПД, возложен контроль «поведения» оконного механизма. Это делается посредством «обратной связи». Принимающий TCP-процесс пытается информировать передающий о состоянии своего буфера, точнее о наличии в нем свободного места. Для этого он при подтверждениях сообщает предлагаемое окно (announced равно advertised равно offered window). В качестве размера предлагаемого окна указывается размер текущего окна приема. Последствия разупорядочивания сегментов с данными такому подходу не противоречат.</p>

<p>Максимальный размер любого из окон не может превышать размер соответствующего буфера (например, 8&nbsp;килобайтов).</p>

<p>В результате, можно сделать вывод о том, что на работу соединения влияют приложения, TCP-процессы и сетевой уровень.</p>

<p>В идеале, при полностью сбалансированной работе, размер текущего окна передатчика равен размеру предлагаемого окна, то есть равен размеру текущего окна приемника. А если еще и буферы освобождаются «мгновенно», то этот размер совпадает с размером доступного окна и размерами буферов. Алгоритмы TCP направлены на «уравнивание» всех упомянутых окон.</p>

<div align="center">
<img src="lk09.11.bmp">
<br>
Рисунок -- Формат заголовка TCP
</div>

<p>Поля:<br>
1.&nbsp;Source Port -- программный порт источника.<br>
2.&nbsp;Destination Port -- программный порт назначения.<br>
3.&nbsp;Sequence Number (SN) -- последовательный номер (сегмента).<br>
4.&nbsp;Acknowledgment Number (AN) -- подтверждающий номер.<br>
5.&nbsp;Data Offset -- смещение данных (в 32-ухбитных словах).<br>
6.&nbsp;Reserved -- зарезервировано (должно равняться нулю).<br>
7.&nbsp;URG (URGent Pointer field significant) -- флаг значимости указателя на экстренные данные.<br>
8.&nbsp;ACK (ACKnowledgment field significant) -- флаг значимости подтверждающего номера.<br>
9.&nbsp;NS (Nonce Sum) -- флаг -- контрольная сумма для проверки правильности кодов явных уведомлений о заторах (связан с QoS, связан с IP-заголовком) (RFC&nbsp;3540).<br>
10.&nbsp;CWR (Congestion Window Reduced) -- флаг уменьшения окна затора при явном уведомлении о заторе (RFC&nbsp;3168).<br>
11.&nbsp;ECE (Explicit Congestion Notification Echo) -- флаг подтверждения явного уведомления о заторе (RFC&nbsp;3168).<br>
12.&nbsp;PSH (PuSH Function) -- флаг принудительной доставки данных (без буферизации).<br>
13.&nbsp;RST (ReSeT the connection) -- флаг разрыва соединения (например, из-за сбоя на одной из взаимодействующих сторон).<br>
14.&nbsp;SYN (SYNchronize sequence numbers) -- флаг синхронизации последовательных номеров.<br>
15.&nbsp;FIN (No more data from sender) -- флаг последних данных.<br>
16.&nbsp;Window (W) -- предлагаемое окно.<br>
17.&nbsp;Checksum -- контрольная сумма.<br>
18.&nbsp;Urgent Pointer -- указатель на экстренные данные (RFC&nbsp;6093).<br>
19.&nbsp;Options -- опции (например, MSS).<br>
20.&nbsp;Padding -- наполнитель.</p>

<p>Функционирование оконного механизма TCP базируется на использовании трех полей в заголовке сегмента: SN, AN, W, и трех флагов (из шести стандартизованных изначально): SYN, ACK, FIN.</p>

<p>Установление TCP-соединения, известное как «тройное рукопожатие» (three-way handshake), основывается на использовании флагов SYN и ACK.</p>

<div align="center">
<img src="lk09.12.bmp">
<br>
Рисунок -- Установление TCP-соединения
</div>

<p>(На этом и последующих рисунках указаны ключевые задействованные флаги и поля. Сплошной линией обозначены сегменты с данными, пунктирной -- сугубо служебные.)</p>

<p>Сначала TCP-процесс -- инициатор взаимодействия (на стороне клиента) отправляет служебный сегмент с установленным флагом SYN, тем самым сообщая о своих намерениях (первое «рукопожатие»). Затем запрашиваемый TCP-процесс (на стороне сервера), если он согласен взаимодействовать, подтверждает это ответным служебным сегментом с двумя установленными флагами SYN и ACK (второе «рукопожатие»). Наконец, инициатор отвечает еще одним служебным сегментом с установленным флагом ACK, тем самым подтверждая подтверждение (третье «рукопожатие»).</p>

<p>Не смотря на то, что процесс установления соединения несимметричен, в дальнейшем, в общем случае, оно используется в полнодуплексном режиме.</p>

<div align="center">
<img src="lk09.13.bmp">
<br>
Рисунок -- Пересылка данных по TCP-соединению
</div>

<p>Очень важно, что на обмен сегментами нужно смотреть с двух сторон. При этом один и тот же TCP-процесс, находящийся по одну сторону соединения, одновременно может выступать в качестве как передатчика данных, так и приемника данных. Полнодуплексность самого соединения достигается за счет того, что передаваемый в определенном направлении сегмент служит одновременно для транспортировки как данных и связанных с ними служебных полей от передающей составляющей TCP-процесса, так и подтверждений и связанных с ними других служебных полей от принимающей составляющей TCP-процесса.</p>

<p>В СПД одновременно могут находиться множество сегментов, относящихся к одному соединению. Применительно к данным в одном сегменте, соединение является полудуплексным, так как сегмент не может содержать более одного поля с ними.</p>

<p>По правилу протокола, поле SN пересылаемого сегмента отражает собственный SN этого сегмента. По другому правилу, в поле AN указывается SN ожидаемого сегмента, коим является следующий по порядку сегмент.</p>

<p>При установлении соединения данные не пересылаются. Поэтому, для того чтобы не нарушать указанные правила, в качестве SNs используют невключенные в нумерацию байтов сообщения ISNs, а в качестве ANs -- просто инкрементированные SNs. Обойтись без передачи SNs при установлении соединения невозможно, так как стороны должны однозначно идентифицировать это соединение. После синхронизации SNs соединение считается установленным (established).</p>

<p>Флаг SYN используется только при установлении соединения, а флаг ACK -- в каждом ответном сегменте.</p>

<p>Не смотря на предоставляемые возможности, данные вполне могут пересылаться только в одном направлении, то есть в симплексном режиме. При этом в направлении, попутном направлению пересылки данных, в качестве AN используется SN следующего по порядку несуществующего (вообще, либо уже, либо пока) сегмента, что никоим образом не противоречит уже приведенным правилам. Если сегментов с данными пересылается несколько, то ANs дублируются столько раз, сколько нужно. Это приводит к дублированию SNs в ответных сегментах без данных. Аналогичные дублирования возникают и при приостановке пересылки данных в определенном направлении.</p>

<p>Поскольку при установлении соединения оно всегда открывается в двух направлениях (по инициативе клиента, но может использоваться в одном любом направлении), для нормального завершения оно и закрыто должно быть в обоих направлениях.</p>

<p>Для закрытия соединения в своем направлении, сторона, в соответствующем сегменте (обычно с последними данными), устанавливает флаг FIN.</p>

<div align="center">
<img src="lk09.14.bmp">
<br>
Рисунок -- Нормальное завершение TCP-соединения
</div>

<p>Соединение, нормально закрытое только в одном направлении, или ненормально завершенное на одной из сторон без уведомления другой стороны (в результате сбоя) называют полуоткрытым (half-open).</p>

<p>Размер предлагаемого окна в поле W может изменяться каждый раз для соответствующей коррекции текущего окна передачи, в том числе и при установлении соединения для изменения размера текущего окна передачи по умолчанию.</p>

<div align="center">
<img src="lk09.15.bmp">
<br>
Рисунок -- Коррекция текущего окна передачи TCP-соединения
</div>

<p>В случае задания нулевого значения поля W передача данных фактически запрещается. После освобождения места в буфере приема подтверждение обязательно повторяется с уже ненулевым полем W, что «разблокирует» передающую сторону.</p>

<p>Проблема возможной потери в СПД некоторых сегментов решается с помощью тайм-аутов.</p>

<div align="center">
<img src="lk09.16.bmp">
<br>
Рисунок -- Гарантия доставки по TCP-соединению
</div>

<p>Передающий TCP-процесс определяет потерю сегмента с данными либо его подтверждения по отсутствию этого подтверждения в течение установленного интервала времени. После наступления тайм-аута сегмент с данными передается повторно.</p>

<p>Отрицательные подтверждения не предусмотрены вообще. Принимающий TCP-процесс подтверждает все принятые сегменты с данными, причем подтверждает всегда. При этом если принята копия (что говорит о потере подтверждения), то она удаляется.</p>

<p>Получение сегмента с SN больше ожидаемого говорит о возможной потере сегментов с данными или о разупорядочивании.</p>

<p>Важно правильно оценивать время «отклика системы». Поэтому время ожидания подтверждений рассчитывается на основе показаний таймеров и корректируется. При этом первостепенное значение имеет параметр RTT (Round-Trip Time) -- суммарное время пересылки по СПД сегмента с данными и его подтверждения.</p>

<p>Протокол TCP обладает несколькими дополнительными возможностями. Возможна пересылка экстренных данных (urgent data) и ускоренная пересылка (push function).</p>

<p>Состояния TCP-процесса стандартизированы и предусмотрена диаграмма переходов между состояниями.</p>

<p>Для обеспечения своей функциональности TCP-процесс должен хранить множество ассоциированных с каждым соединением служебных данных.</p>

<p>Как было сказано выше, несбалансированность соединений может возникать из-за разной производительности задействованных подсистем, плюс из-за изменения производительности этих подсистем.</p>

<p>Следует отметить, что базовая редакция стандарта TCP предоставила реализациям определенную вольность (как во многих других случаях со стандартами). Это привело к тому, что при полном соблюдении требований во многих случаях оконный механизм TCP может оказаться неэффективным. «Разношерстность» реализаций усугубляет ситуацию. Как следствие, потребовалась разработка дополнений к базовому алгоритму. Новые алгоритмы оперируют с новыми понятиями.</p>

<p>В частности, хорошо известна проблема, вошедшая в историю под обобщенным названием «синдром глупого окна» («silly window syndrome»), в свое время «стопорившая» значительную часть пространства Internet. Синдром может возникать по разным причинам и проявляется в том, что текущее окно передачи не соответствует состоянию приемника, тем самым не позволяя его как следует «нагрузить» либо, наоборот, «разгрузить».</p>

<p>Решение Нэгла (Nagle) позволяет побороть «синдром глупого окна» когда передающей стороне требуется часто отправлять небольшие сегменты с данными.</p>

<p>Решение Кларка (Clark) позволяет побороть «синдром глупого окна» когда принимающей стороной часто анонсируется небольшое предлагаемое окно.</p>

<p>Также стандартизированы четыре дополнения Ван Якобсона (Van Jacobson), призванные бороться с перегрузками в СПД (последнее RFC -- RFC&nbsp;5681):</p>

<p>1.&nbsp;Медленный старт (slow start).<br>
Идея заключается в том, что в начале передачи размер текущего окна передачи нужно увеличивать не «скачком», а плавно, пропорционально скорости получения подтверждений (не превышая размер предлагаемого окна).</p>

<p>Рекомендуемые формулы:</p>

<p><em>IW</em> = 2 * <em>SMSS</em>, если <em>SMSS</em> &gt; 2190&nbsp;Bytes ,<br>
<em>IW</em> = 3 * <em>SMSS</em>, если 2190 Bytes &gt;= <em>SMSS</em> &gt; 1095&nbsp;Bytes ,<br>
<em>IW</em> = 4 * <em>SMSS</em>, если <em>SMSS</em> &lt;= 1095&nbsp;Bytes ,</p>

<p>где <em>IW</em> (initial window) -- начальное значение текущего окна передачи;</p>

<p><em>cwnd</em> += min (<em>N</em>, <em>SMSS</em>) ,</p>

<p>где <em>cwnd</em> (congestion window) -- текущее окно передачи (в данном случае, окно затора), <em>N</em> -- количество подтвержденных байтов, <em>SMSS</em> (sender MSS) -- MSS передатчика.</p>

<p>2.&nbsp;Избегание затора (congestion avoidance).<br>
Состоит в сдерживании экспоненциального роста размера текущего окна передачи после преодоления им некоторого порога. Как правило переход к избеганию затора происходит после медленного старта.</p>

<p>Рекомендуемые формулы:</p>

<p><em>ssthresh</em> = max (<em>FlightSize</em> / 2, 2 * <em>SMSS</em>) ,</p>

<p>где <em>ssthresh</em> (slow start threshold) -- порог перехода от медленного старта к избеганию затора, <em>FlightSize</em> -- количество еще неподтвержденных байтов;</p>

<p><em>cwnd</em> += <em>SMSS</em> * <em>SMSS</em> / <em>cwnd</em> .</p>

<p>3.&nbsp;Быстрая повторная передача (fast retransmit).<br>
При получении принимающей стороной разупорядоченного сегмента с данными (возможно из-за потери ожидаемого сегмента с данными) незамедлительный повтор подтверждения с AN недостающего сегмента с данными. При получении передающей стороной трех одинаковых подтверждений незамедлительный повтор сегмента с данными согласно AN. Что, в некоторых ситуациях, позволяет успешно песлать потерянный сегмент еще до наступления тайм-аута.</p>

<div align="center">
<img src="lk09.17.bmp">
<br>
Рисунок -- Быстрая повторная передача TCP
</div>

<p>4.&nbsp;Быстрое восстановление (fast recovery).<br>
После обнаружения затора, переход сразу к избеганию коллизий, минуя стадию медленного старта. Как правило в связке с быстрой повторной передачей.</p>

<div align="center">
<img src="lk09.18.bmp">
<br>
Рисунок -- TCP сongestion сontrol
</div>

<p>Последствия потерь и разупорядочивания сегментов заключаются в разрушении «маятника» взаимодействия и приводят к необходимости еще одной важной оптимизации, четко проявляющейся при быстрой повторной передаче. Согласно базовому алгоритму все сегменты должны быть подтверждены, а значит, после быстрой повторной передачи принимающая сторона должна послать все недостающие подтверждения. Но стороны могут «договориться», что текущий AN отражает номер первого ожидаемого получателем сегмента и автоматически подтверждает все сегменты с меньшими номерами (cumulative acknowlegement).</p>

<p>Были разработаны и другие усовершенствования, основанные, например, на манипулировании с RTT (RFC&nbsp;6298, RFC&nbsp;7323).</p>

<p>Протокол транспортного уровня UDP (User Datagram Protocol) (RFC&nbsp;768) реализует способ пересылки данных без гарантии доставки, часто называемый <em>дейтаграммным</em> (datagram) (хотя user datagram -- это пакет с контролируемыми пользователем данными, а datagram -- это любой пакет с данными).</p>

<div align="center">
<img src="lk09.19.bmp">
<br>
Рисунок -- Формат заголовка UDP
</div>

<p>Поля:<br>
1.&nbsp;Source Port -- программный порт источника.<br>
2.&nbsp;Destination Port -- программный порт назначения.<br>
3.&nbsp;Length -- длина дейтаграммы включая заголовок (в байтах).<br>
4.&nbsp;Checksum -- контрольная сумма (псевдозаголовка, плюс заголовка, плюс данных).</p>

<p>При вкладывании UDP-дейтаграммы в IP-пакет (IPv4, IPv6), между UDP-заголовком и IP-заголовком вставляется дополнительный так называемый UDP-псевдозаголовок, в котором дублируются некоторые значения из основного IP-заголовка.</p>

</div>

</BODY>
</HTML>
